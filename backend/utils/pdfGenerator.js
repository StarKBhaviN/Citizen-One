import PDFDocument from "pdfkit"
import fs from "fs"
import path from "path"
import { fileURLToPath } from "url"

const __dirname = path.dirname(fileURLToPath(import.meta.url))

// Generate complaint report PDF
export const generateComplaintReport = async (complaint, outputPath = null) => {
  return new Promise((resolve, reject) => {
    try {
      // Create a new PDF document
      const doc = new PDFDocument({ margin: 50 })

      // If outputPath is not provided, create one in the temp directory
      if (!outputPath) {
        const tempDir = path.join(__dirname, "..", "temp")

        // Create temp directory if it doesn't exist
        if (!fs.existsSync(tempDir)) {
          fs.mkdirSync(tempDir, { recursive: true })
        }

        outputPath = path.join(tempDir, `complaint-${complaint.complaintId}.pdf`)
      }

      // Pipe the PDF to a file
      const stream = fs.createWriteStream(outputPath)
      doc.pipe(stream)

      // Add content to the PDF

      // Header
      doc.fontSize(20).text("Complaint Report", { align: "center" })
      doc.moveDown()

      // Complaint ID and Date
      doc.fontSize(12).text(`Complaint ID: ${complaint.complaintId}`, { align: "left" })
      doc.fontSize(12).text(`Date: ${new Date(complaint.createdAt).toLocaleDateString()}`, { align: "left" })
      doc.fontSize(12).text(`Status: ${complaint.status.replace("_", " ").toUpperCase()}`, { align: "left" })
      doc.moveDown()

      // Horizontal line
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke()
      doc.moveDown()

      // Complaint details
      doc.fontSize(16).text("Complaint Details", { underline: true })
      doc.moveDown()

      doc.fontSize(12).text(`Category: ${complaint.category.replace("_", " ").toUpperCase()}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Location: ${complaint.location}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Priority: ${complaint.priority.toUpperCase()}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text("Description:")
      doc.fontSize(10).text(complaint.description, { align: "justify" })
      doc.moveDown()

      // Department details if assigned
      if (complaint.assignedTo && complaint.assignedTo.department) {
        doc.fontSize(16).text("Department Information", { underline: true })
        doc.moveDown()

        if (typeof complaint.assignedTo.department === "object") {
          doc.fontSize(12).text(`Department: ${complaint.assignedTo.department.name}`)
        } else {
          doc.fontSize(12).text("Department: Assigned")
        }

        if (complaint.assignedTo.officer && typeof complaint.assignedTo.officer === "object") {
          doc.fontSize(12).text(`Officer: ${complaint.assignedTo.officer.name}`)
        }

        doc.moveDown()
      }

      // Timeline
      doc.fontSize(16).text("Complaint Timeline", { underline: true })
      doc.moveDown()

      complaint.timeline.forEach((event, index) => {
        const statusText = event.status.replace("_", " ").toUpperCase()
        const dateText = new Date(event.timestamp).toLocaleString()

        doc.fontSize(12).text(`${index + 1}. ${statusText} - ${dateText}`)
        doc.fontSize(10).text(`   ${event.description}`)

        if (event.department && typeof event.department === "object") {
          doc.fontSize(10).text(`   Department: ${event.department.name}`)
        }

        doc.moveDown(0.5)
      })

      // Feedback if available
      if (complaint.feedback && complaint.feedback.rating) {
        doc.moveDown()
        doc.fontSize(16).text("Citizen Feedback", { underline: true })
        doc.moveDown()

        doc.fontSize(12).text(`Rating: ${complaint.feedback.rating}/5`)

        if (complaint.feedback.comment) {
          doc.fontSize(12).text("Comment:")
          doc.fontSize(10).text(complaint.feedback.comment, { align: "justify" })
        }

        doc.moveDown()
      }

      // Footer
      doc.fontSize(10).text("This is an official document generated by the Citizen Complaint Management System.", {
        align: "center",
        color: "gray",
      })

      // Finalize the PDF
      doc.end()

      // When the stream is finished, resolve the promise with the file path
      stream.on("finish", () => {
        resolve(outputPath)
      })
    } catch (error) {
      reject(error)
    }
  })
}

// Generate department report PDF
export const generateDepartmentReport = async (department, complaints, period, outputPath = null) => {
  return new Promise((resolve, reject) => {
    try {
      // Create a new PDF document
      const doc = new PDFDocument({ margin: 50 })

      // If outputPath is not provided, create one in the temp directory
      if (!outputPath) {
        const tempDir = path.join(__dirname, "..", "temp")

        // Create temp directory if it doesn't exist
        if (!fs.existsSync(tempDir)) {
          fs.mkdirSync(tempDir, { recursive: true })
        }

        outputPath = path.join(tempDir, `department-report-${department.code}-${Date.now()}.pdf`)
      }

      // Pipe the PDF to a file
      const stream = fs.createWriteStream(outputPath)
      doc.pipe(stream)

      // Add content to the PDF

      // Header
      doc.fontSize(20).text("Department Performance Report", { align: "center" })
      doc.moveDown()

      // Department info
      doc.fontSize(16).text(`${department.name} (${department.code})`, { align: "center" })
      doc.fontSize(12).text(`Report Period: ${period}`, { align: "center" })
      doc.fontSize(12).text(`Generated on: ${new Date().toLocaleDateString()}`, { align: "center" })
      doc.moveDown()

      // Horizontal line
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke()
      doc.moveDown()

      // Department details
      doc.fontSize(16).text("Department Information", { underline: true })
      doc.moveDown()

      doc.fontSize(12).text(`Description: ${department.description || "N/A"}`)
      doc.moveDown(0.5)

      if (department.head && typeof department.head === "object") {
        doc.fontSize(12).text(`Department Head: ${department.head.name}`)
      }
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Contact Email: ${department.contactEmail || "N/A"}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Contact Phone: ${department.contactPhone || "N/A"}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Status: ${department.status.toUpperCase()}`)
      doc.moveDown()

      // Complaint statistics
      doc.fontSize(16).text("Complaint Statistics", { underline: true })
      doc.moveDown()

      // Count complaints by status
      const statusCounts = {
        submitted: 0,
        under_review: 0,
        in_progress: 0,
        resolved: 0,
        reopened: 0,
      }

      complaints.forEach((complaint) => {
        if (statusCounts[complaint.status] !== undefined) {
          statusCounts[complaint.status]++
        }
      })

      doc.fontSize(12).text(`Total Complaints: ${complaints.length}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Submitted: ${statusCounts.submitted}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Under Review: ${statusCounts.under_review}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`In Progress: ${statusCounts.in_progress}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Resolved: ${statusCounts.resolved}`)
      doc.moveDown(0.5)

      doc.fontSize(12).text(`Reopened: ${statusCounts.reopened}`)
      doc.moveDown()

      // Calculate resolution rate
      const resolutionRate = complaints.length > 0 ? ((statusCounts.resolved / complaints.length) * 100).toFixed(2) : 0

      doc.fontSize(12).text(`Resolution Rate: ${resolutionRate}%`)
      doc.moveDown()

      // Calculate average resolution time for resolved complaints
      const resolvedComplaints = complaints.filter((c) => c.status === "resolved" && c.resolvedAt && c.createdAt)

      let avgResolutionTime = 0
      if (resolvedComplaints.length > 0) {
        const totalTime = resolvedComplaints.reduce((sum, complaint) => {
          const resolutionTime = new Date(complaint.resolvedAt) - new Date(complaint.createdAt)
          return sum + resolutionTime
        }, 0)

        avgResolutionTime = totalTime / resolvedComplaints.length / (1000 * 60 * 60 * 24) // in days
      }

      doc.fontSize(12).text(`Average Resolution Time: ${avgResolutionTime.toFixed(2)} days`)
      doc.moveDown()

      // Recent complaints table
      doc.fontSize(16).text("Recent Complaints", { underline: true })
      doc.moveDown()

      // Table headers
      const tableTop = doc.y
      const tableHeaders = ["ID", "Category", "Status", "Created", "Priority"]
      const columnWidth = 100

      // Draw headers
      tableHeaders.forEach((header, i) => {
        doc.fontSize(10).text(header, 50 + i * columnWidth, tableTop, { width: columnWidth, align: "left" })
      })

      // Draw header line
      doc
        .moveTo(50, tableTop + 15)
        .lineTo(550, tableTop + 15)
        .stroke()

      // Draw rows
      const recentComplaints = complaints.slice(0, 10) // Get 10 most recent complaints

      recentComplaints.forEach((complaint, i) => {
        const rowY = tableTop + 25 + i * 20

        // ID
        doc.fontSize(8).text(complaint.complaintId, 50, rowY, { width: columnWidth, align: "left" })

        // Category
        doc.fontSize(8).text(complaint.category.replace("_", " ").toUpperCase(), 50 + columnWidth, rowY, {
          width: columnWidth,
          align: "left",
        })

        // Status
        doc.fontSize(8).text(complaint.status.replace("_", " ").toUpperCase(), 50 + columnWidth * 2, rowY, {
          width: columnWidth,
          align: "left",
        })

        // Created
        doc.fontSize(8).text(new Date(complaint.createdAt).toLocaleDateString(), 50 + columnWidth * 3, rowY, {
          width: columnWidth,
          align: "left",
        })

        // Priority
        doc
          .fontSize(8)
          .text(complaint.priority.toUpperCase(), 50 + columnWidth * 4, rowY, { width: columnWidth, align: "left" })
      })

      // Footer
      doc.fontSize(10).text("This is an official document generated by the Citizen Complaint Management System.", {
        align: "center",
        color: "gray",
      })

      // Finalize the PDF
      doc.end()

      // When the stream is finished, resolve the promise with the file path
      stream.on("finish", () => {
        resolve(outputPath)
      })
    } catch (error) {
      reject(error)
    }
  })
}

